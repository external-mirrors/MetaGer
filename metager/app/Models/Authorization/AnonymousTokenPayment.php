<?php

namespace App\Models\Authorization;

use Cache;
use Illuminate\Contracts\Cache\LockTimeoutException;
use Illuminate\Support\Facades\Redis;

/**
 * Holds information about a anonymous token
 * payment.
 */
class AnonymousTokenPayment
{
    /**
     * Identifier for this payment. Used by payment process to fetch initial information about this
     * payment. This identifier can be defined by the payment client and should be different on every payment request
     * @var string
     */
    private ?string $payment_id;
    /**
     * In rare occasions it might happen that a payment_id is used multiple times for mutliple parallel requests.
     * This is unwanted but might happen if for some reason mutliple processes start requests in parallel before changing the payment_id
     * The webextension for example is not able to force requests to wait for changing the payment_id
     * The UID is generated by the publish function and used by payment clients when attaching tokens
     * @var string
     */
    private ?string $payment_uid;
    public readonly float $cost;
    /** @var Token[] */
    public array $tokens = [];
    /** @var Token[] */
    public array $decitokens = [];

    /**
     * @param float $cost
     * @param Token[] $tokens
     */
    public function __construct(float $cost, array $tokens, array $decitoken, string|null $payment_id = null, string|null $payment_uid = null)
    {
        $this->cost = $cost;
        foreach ($tokens as $token) {
            if ($token instanceof Token) {
                $this->tokens[] = $token;
            }
        }
        foreach ($decitoken as $token) {
            if ($token instanceof Token) {
                $this->decitokens[] = $token;
            }
        }
        $this->payment_id = $payment_id;
        $this->payment_uid = $payment_uid;
    }

    public function getAvailableTokenCount(): float
    {
        $available_token = 0;
        foreach ($this->tokens as $token) {
            $available_token++;
        }
        foreach ($this->decitokens as $token) {
            $available_token += 0.1;
        }
        return $available_token;
    }

    public function checkTokens(): bool
    {
        if (sizeof($this->tokens) === 0 && sizeof($this->decitokens) === 0) {
            return false;
        }
        $url = config("metager.metager.keymanager.server") ?: config("app.url") . "/keys/token/check";

        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_HTTPHEADER => [
                "Authorization: Bearer " . config("metager.metager.keymanager.access_token"),
                "Content-Type: application/json"
            ],
            CURLOPT_TIMEOUT => 5,
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => json_encode(["tokens" => $this->tokens, "decitokens" => $this->decitokens]),
            CURLOPT_USERAGENT => "MetaGer"
        ]);

        $result = curl_exec($ch);
        $response_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        if ($response_code === 200) {
            return true;
        } elseif ($response_code === 422) {
            $this->tokens = [];
            $this->decitokens = [];
            $result = json_decode($result);
            if ($result === null) {
                return false;
            }
            $this->tokens = $this->parseError($result);
        }
        return false;
    }

    public function makePayment(float $cost)
    {
        if ($this->getAvailableTokenCount() < $cost)
            return false;
        $tokens_to_use = [];
        $decitokens_to_use = [];
        $tokens = floor($cost);
        $decitokens = ceil(($cost - $tokens) * 10);
        if (sizeof($this->decitokens) < $this->decitokens) {
            $tokens++;
            $decitokens = 0;
        }
        while ($tokens >= 1) {
            $tokens_to_use[] = array_shift($this->tokens);
            $tokens--;
        }
        $cost = ceil($cost * 10);
        while ($decitokens >= 1) {
            $decitokens_to_use[] = array_shift($this->decitokens);
            $decitokens--;
        }

        $url = config("metager.metager.keymanager.server") ?: config("app.url") . "/token/use";
        $result_hash = md5($url . microtime(true));
        $mission = [
            "resulthash" => $result_hash,
            "url" => $url,
            "useragent" => "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:81.0) Gecko/20100101 Firefox/81.0",
            "headers" => [
                "Authorization" => "Bearer " . config("metager.metager.keymanager.access_token"),
                "Content-Type" => "application/json",
            ],
            "cacheDuration" => 0,
            "name" => "Key Login",
            "proxy" => false,
            // Don't use Http Proxy if defined in .env
            "curlopts" => [
                CURLOPT_POST => true,
                CURLOPT_TIMEOUT => 15,
                CURLOPT_POSTFIELDS => json_encode(["tokens" => $tokens_to_use, "decitokens" => $decitokens_to_use])
            ]
        ];
        $mission = json_encode($mission);
        Redis::rpush(\App\MetaGer::FETCHQUEUE_KEY, $mission);
        $this->usedTokens += sizeof($tokens_to_use);
        $this->updateCookie();

        return true;
    }

    private function parseError($result)
    {
        $new_tokens = [];
        foreach ($result->errors as $error) {
            if ($error->msg === "Invalid Signatures") {
                // One or more tokens are invalid. Remove the invalid tokens
                foreach ($error->value as $error_token) {
                    if ($error_token->status === "ok") {
                        $new_tokens[] = new Token($error_token->token, $error_token->signature, $error_token->date);
                    }
                }
            }
        }
        return $new_tokens;
    }

    /**
     * Attempts to add a token to this payment
     * 
     * @return bool TRUE if the token has valid syntax and was added successfully
     */
    public function addJSONToken(object $token_json): bool
    {
        $token = self::PARSE_TOKEN($token_json);
        if (is_null($token)) {
            return false;
        }
        $this->tokens[] = $token;
        return true;
    }

    /**
     * Attempts to add a token to this payment
     * 
     * @return bool TRUE if the token has valid syntax and was added successfully
     */
    public function addJSONDeciToken(object $token_json): bool
    {
        $token = self::PARSE_TOKEN($token_json);
        if (is_null($token)) {
            return false;
        }
        $this->decitokens[] = $token;
        return true;
    }

    public function toJSON(): string
    {
        return json_encode([
            "cost" => $this->cost,
            "payment_id" => $this->payment_id,
            "payment_uid" => $this->payment_uid,
            "tokens" => [
                "tokens" => $this->tokens,
                "decitokens" => $this->decitokens
            ]
        ]);
    }

    /**
     * Publishes the payment inside of redis cache to be retrieved by the payment process
     * so it can attach tokens to it
     * @param string $payment_id
     * @return string
     */
    public function publish(string $payment_id): string|null
    {
        if (!is_null($this->payment_id))
            return null;
        if (!is_null($this->payment_uid))
            return $this->payment_uid;
        $this->payment_id = $payment_id;
        $this->payment_uid = uniqid('', true);

        // Lock this payment so we can only publish once
        $lock = Cache::lock("payment:anonymous:$payment_id", 30);
        try {
            $lock->block(10);
            Redis::rpush("payment:anonymous:$payment_id", $this->toJSON());
            Redis::expire("payment:anonymous:$payment_id", 30);
            return $this->payment_uid;
        } catch (LockTimeoutException $e) {
            return null;
        }
    }
    /**
     * Loads a preivously published Payment, removes it from memory and releases the existing lock
     * @param string $payment_id
     * @return \App\Models\Authorization\AnonymousTokenPayment|null The previously stored AnonymousTokenPayment object
     */
    public static function UNPUBLISH(string $payment_id): AnonymousTokenPayment|null
    {
        $lock = Cache::lock("payment:anonymous:$payment_id", 30);
        $payment_json = Redis::blpop("payment:anonymous:$payment_id", 30);
        $lock->forceRelease();
        if (!is_null($payment_json)) {
            return AnonymousTokenPayment::fromJSON($payment_json[1]);
        }
        return null;
    }

    public static function fromJSON(string $json): AnonymousTokenPayment|null
    {
        $payment_json = json_decode($json);
        if (is_null($payment_json)) {
            return null;
        }
        if (!property_exists($payment_json, "cost")) {
            return null;
        }
        $cost = filter_var($payment_json->cost, FILTER_VALIDATE_FLOAT);
        if ($cost === false) {
            return null;
        }
        if (!property_exists($payment_json, "payment_id") || (!is_string($payment_json->payment_id) && !is_null($payment_json->payment_id))) {
            return null;
        }
        $payment_id = $payment_json->payment_id;
        if (!property_exists($payment_json, "payment_uid") || (!is_string($payment_json->payment_uid) && !is_null($payment_json->payment_uid))) {
            return null;
        }
        $payment_uid = $payment_json->payment_uid;
        if (!property_exists($payment_json, "tokens")) {
            return null;
        }
        if (!property_exists($payment_json->tokens, "tokens") || !is_array($payment_json->tokens->tokens)) {
            return null;
        }
        $tokens = [];
        foreach ($payment_json->tokens->tokens as $token) {
            $token = self::PARSE_TOKEN($token);
            if (!is_null($token)) {
                $tokens[] = $token;
            }
        }
        if (!property_exists($payment_json->tokens, "decitokens")) {
            return null;
        }
        $decitokens = [];
        foreach ($payment_json->tokens->decitokens as $token) {
            $token = self::PARSE_TOKEN($token);
            if (!is_null($token)) {
                $decitokens[] = $token;
            }
        }
        return new AnonymousTokenPayment($cost, $tokens, $decitokens, $payment_id, $payment_uid);
    }

    /**
     * Tries to convert a json decoded token object into a Token class 
     * @param object $token
     * @return Token|null
     */
    private static function PARSE_TOKEN(object $token): Token|null
    {
        if (!property_exists($token, "token") || !property_exists($token, "date") || !property_exists($token, "signature")) {
            return null;
        }
        $tokenString = $token->token;
        if (!is_string($tokenString)) {
            return null;
        }
        $tokenSignature = $token->signature;
        if (!is_string($tokenSignature)) {
            return null;
        }
        $tokenDate = $token->date;
        if (!is_string($tokenDate)) {
            return null;
        }
        return new Token($token, $tokenSignature, $tokenDate);
    }

}