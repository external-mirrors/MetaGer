<?php

namespace App\Models\Authorization;

use Cache;
use Cookie;
use Illuminate\Contracts\Cache\LockTimeoutException;
use Illuminate\Support\Facades\Redis;
use RateLimiter;
use Request;

/**
 * Holds information about a anonymous token
 * payment.
 */
class AnonymousTokenPayment
{
    const MAX_PARALLEL_ASYNC_PAYMENTS = 40;
    const MAX_PARALLEL_ASYNC_PAYMENTS_RLKEY = "payment:anonymous"; // Ratelimiter Key
    /**
     * Identifier for this payment. Used by payment process to fetch initial information about this
     * payment. This identifier can be defined by the payment client and should be different on every payment request
     * @var string
     */
    private ?string $payment_id = null;
    /**
     * In rare occasions it might happen that a payment_id is used multiple times for mutliple parallel requests.
     * This is unwanted but might happen if for some reason mutliple processes start requests in parallel before changing the payment_id
     * The webextension for example is not able to force requests to wait for changing the payment_id
     * The UID is generated by the publish function and used by payment clients when attaching tokens
     * @var string
     */
    private ?string $payment_uid = null;
    /**
     * A key should never be defined for an anonymous payment.
     * but if it is. There was an error with the token payment which falls back to using the key instead
     */
    public ?string $key;
    public float $cost;
    /**
     * When making a payment we will charge up necessary credits using anonymous token
     * and then substract the cost from this credits
     * @var float
     */
    private float $credits = 0;
    /** @var Token[] */
    public array $tokens = [];
    /** @var Token[] */
    public array $decitokens = [];
    /** @var Token[] */
    public array $used_tokens = [];
    /** @var Token[] */
    public array $used_decitokens = [];

    private $key_api_server;

    /**
     * @param float $cost
     * @param Token[] $tokens
     */
    public function __construct(float $cost, array $tokens, array $decitoken, string|null $payment_id = null, string|null $payment_uid = null, string $key = null, $credits = 0)
    {
        $this->key_api_server = config("metager.metager.keymanager.server") . "/api/json";
        $this->key = $key;
        $this->cost = round($cost, 1);
        $this->credits = round($credits, 1);
        foreach ($tokens as $token) {
            if ($token instanceof Token) {
                $this->tokens[] = $token;
            }
        }
        foreach ($decitoken as $token) {
            if ($token instanceof Token) {
                $this->decitokens[] = $token;
            }
        }

        if (uuid_is_valid($payment_id)) {
            $this->payment_id = $payment_id;
        }
        $this->payment_uid = $payment_uid;
        $this->updateCookie();
    }

    public function getAvailableTokenCount(): float
    {
        $available_token = 0;
        foreach ($this->tokens as $token) {
            $available_token++;
        }
        foreach ($this->decitokens as $token) {
            $available_token += 0.1;
        }
        return round($available_token, 1);
    }

    public function checkTokens(): bool
    {
        if (sizeof($this->tokens) === 0 && sizeof($this->decitokens) === 0) {
            return false;
        }
        $url = $this->key_api_server . "/token/check";

        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_HTTPHEADER => [
                "Authorization: Bearer " . config("metager.metager.keymanager.access_token"),
                "Content-Type: application/json"
            ],
            CURLOPT_TIMEOUT => 5,
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => json_encode(["tokens" => $this->tokens, "decitokens" => $this->decitokens]),
            CURLOPT_USERAGENT => "MetaGer"
        ]);

        $result = curl_exec($ch);
        $response_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        if ($response_code === 200) {
            return true;
        } elseif ($response_code === 422) {
            $this->tokens = [];
            $this->decitokens = [];
            $result = json_decode($result);
            if ($result === null) {
                return false;
            }
            foreach ($result->errors as $error) {
                if (!in_array($error->param, ["tokens", "decitokens"]))
                    continue;
                if (!in_array($error->msg, ["Invalid Signatures", "Token structure is invalid"]))
                    continue;
                $tokens = [];
                if (property_exists($error, "values")) {
                    $tokens = $error->values;
                } else if (property_exists($error, "value")) {
                    $tokens = $error->value;
                }
                foreach ($tokens as $token) {
                    if ($token->status === "ok") {
                        if ($error->param === "tokens") {
                            $this->tokens[] = new Token($token->token, $token->signature, $token->date);
                        }
                    }
                }
            }
            $this->updateCookie();
        }
        return false;
    }

    public function makePayment(float $cost)
    {
        $credit_to_charge = max(round($cost - $this->credits, 1), 0);
        if ($this->getAvailableTokenCount() < $credit_to_charge)
            return false;

        $tokens_to_use = [];
        $decitokens_to_use = [];

        $cost_payment = $credit_to_charge;
        while ($cost_payment >= 1) {
            $token = array_shift($this->tokens);
            if (is_null($token))
                break;
            $tokens_to_use[] = $token;
            $cost_payment--;
        }
        $this->used_tokens = array_merge($this->used_tokens, $tokens_to_use);
        while ($cost_payment > 0) {
            $token = array_shift($this->decitokens);
            if (is_null($token))
                break;
            $decitokens_to_use[] = $token;
            $cost_payment = round($cost_payment - 0.1, 1);
        }
        $this->used_decitokens = array_merge($this->used_decitokens, $decitokens_to_use);
        while ($cost_payment > 0) {
            $token = array_shift($this->tokens);
            if (is_null($token))
                break;
            $tokens_to_use[] = $token;
            $cost_payment--;
        }
        $this->used_tokens = array_merge($this->used_tokens, $tokens_to_use);

        $this->credits = round($this->credits + ($credit_to_charge - $cost_payment), 1);
        $this->updateCookie();

        $this->credits = round($this->credits - $cost, 1);

        $url = $this->key_api_server . "/token/use";
        $result_hash = md5($url . microtime(true));
        $payment = ["tokens" => $tokens_to_use, "decitokens" => $decitokens_to_use];
        $mission = [
            "resulthash" => $result_hash,
            "url" => $url,
            "useragent" => "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:81.0) Gecko/20100101 Firefox/81.0",
            "headers" => [
                "Authorization" => "Bearer " . config("metager.metager.keymanager.access_token"),
                "Content-Type" => "application/json",
            ],
            "cacheDuration" => 0,
            "name" => "Key Login",
            "proxy" => false,
            // Don't use Http Proxy if defined in .env
            "curlopts" => [
                CURLOPT_POST => true,
                CURLOPT_TIMEOUT => 15,
                CURLOPT_POSTFIELDS => json_encode($payment)
            ]
        ];
        $mission = json_encode($mission);
        Redis::rpush(\App\MetaGer::FETCHQUEUE_KEY, $mission);

        return true;
    }

    private function parseError($result)
    {
        $new_tokens = [];
        foreach ($result->errors as $error) {
            if ($error->msg === "Invalid Signatures" || $error->msg === "Token structure is invalid") {
                // One or more tokens are invalid. Remove the invalid tokens
                foreach ($error->value as $error_token) {
                    if ($error_token->status === "ok") {
                        $new_tokens[] = new Token($error_token->token, $error_token->signature, $error_token->date);
                    }
                }
            }
        }
        return $new_tokens;
    }

    /**
     * Attempts to add a token to this payment
     * 
     * @return bool TRUE if the token has valid syntax and was added successfully
     */
    public function addJSONToken(object $token_json): bool
    {
        $token = self::PARSE_TOKEN($token_json);
        if (is_null($token)) {
            return false;
        }
        $this->tokens[] = $token;
        $this->updateCookie();
        return true;
    }

    /**
     * Attempts to add a token to this payment
     * 
     * @return bool TRUE if the token has valid syntax and was added successfully
     */
    public function addJSONDeciToken(object $token_json): bool
    {
        $token = self::PARSE_TOKEN($token_json);
        if (is_null($token)) {
            return false;
        }
        $this->decitokens[] = $token;
        $this->updateCookie();
        return true;
    }

    public function toJSON(): string
    {
        return json_encode([
            "cost" => $this->cost,
            "missing" => round($this->cost - $this->credits - $this->getAvailableTokenCount(), 1),
            "payment_id" => $this->payment_id,
            "payment_uid" => $this->payment_uid,
            "key" => $this->key,
            "credits" => $this->credits,
            "async_disabled" => self::IS_ASYNC_DISABLED(),
            "tokens" => [
                "tokens" => $this->tokens,
                "decitokens" => $this->decitokens
            ]
        ]);
    }

    /**
     * Publishes the payment inside of redis cache to be retrieved by the payment process
     * so it can attach tokens to it
     * @param string $payment_id
     * @return string
     */
    public function publish(): string|null
    {
        if (is_null($this->payment_id))
            return null;
        if ($this->payment_uid === null)
            $this->payment_uid = uniqid('', true);

        RateLimiter::attempt(self::MAX_PARALLEL_ASYNC_PAYMENTS_RLKEY, self::MAX_PARALLEL_ASYNC_PAYMENTS, function () {
            // Lock this payment so we can only publish once
            $lock = Cache::lock("payment:anonymous:$this->payment_id", 2);
            try {
                $lock->block(10);
                Redis::connection(config("cache.stores.redis.connection"))->rpush("payment:anonymous:$this->payment_id", [$this->toJSON()]);
                Redis::connection(config("cache.stores.redis.connection"))->expire("payment:anonymous:$this->payment_id", 10);
                return $this->payment_uid;
            } catch (LockTimeoutException $e) {
                return null;
            }
        });

        return $this->payment_uid;
    }
    /**
     * Loads a preivously published Payment, removes it from memory and releases the existing lock
     * @param string $payment_id
     * @return \App\Models\Authorization\AnonymousTokenPayment|null The previously stored AnonymousTokenPayment object
     */
    public static function UNPUBLISH(string $payment_id): AnonymousTokenPayment|null
    {
        $block_time = 1;
        if (self::IS_ASYNC_DISABLED())
            $block_time = 0.01;
        $lock = Cache::lock("payment:anonymous:$payment_id", 2);
        $payment_json = Redis::connection(config("cache.stores.redis.connection"))->blpop("payment:anonymous:$payment_id", $block_time);
        $lock->forceRelease();
        if (!is_null($payment_json)) {
            return AnonymousTokenPayment::fromJSON($payment_json[1]);
        }
        return null;
    }

    public static function IS_ASYNC_DISABLED(): bool
    {
        return RateLimiter::tooManyAttempts(self::MAX_PARALLEL_ASYNC_PAYMENTS_RLKEY, self::MAX_PARALLEL_ASYNC_PAYMENTS);
    }

    /**
     * Sends Token payment via redis to the waiting main process which is waiting on the receive function
     * 
     * @return void
     */
    public function send()
    {
        if (!is_null($this->payment_id) & !is_null($this->payment_uid)) {
            Redis::connection(config("cache.stores.redis.connection"))->rpush("payment:anonymous:$this->payment_id:$this->payment_uid", [$this->toJSON()]);
            Redis::connection(config("cache.stores.redis.connection"))->expire("payment:anonymous:$this->payment_id:$this->payment_uid", 60);
        }
        $this->tokens = [];
        $this->decitokens = [];
    }

    public function receive($timeout = 3): float
    {
        if (self::IS_ASYNC_DISABLED()) {
            $timeout = 0.01;
        }
        $timeout = max($timeout, 0.01);
        $payment = Redis::connection(config("cache.stores.redis.connection"))->blmove("payment:anonymous:$this->payment_id:$this->payment_uid", "payment:anonymous:$this->payment_id:$this->payment_uid", "LEFT", "LEFT", $timeout);
        Redis::connection(config("cache.stores.redis.connection"))->expire("payment:anonymous:$this->payment_id:$this->payment_uid", 60);
        RateLimiter::decrement(self::MAX_PARALLEL_ASYNC_PAYMENTS_RLKEY);
        if (is_null($payment))
            return $this->getAvailableTokenCount();
        $payment = AnonymousTokenPayment::fromJSON($payment);
        foreach ($payment->tokens as $token) {
            $this->tokens[] = $token;
        }
        foreach ($payment->decitokens as $token) {
            $this->decitokens[] = $token;
        }
        if (!is_null($payment->key)) {
            $this->key = $payment->key;
        }
        $this->updateCookie();
        return $this->getAvailableTokenCount();
    }

    private function updateCookie()
    {
        if (sizeof($this->tokens) === 0) {
            Cookie::queue(Cookie::forget("tokens", "/", null));
        } else {
            Cookie::queue(Cookie::forever("tokens", json_encode($this->tokens), "/", null, Request::isSecure(), false));
        }
        if (sizeof($this->decitokens) === 0) {
            Cookie::queue(Cookie::forget("decitokens", "/", null));
        } else {
            Cookie::queue(Cookie::forever("decitokens", json_encode($this->decitokens), "/", null, Request::isSecure(), false));
        }
    }

    public static function fromJSON(string $json, bool $trusted = false): AnonymousTokenPayment|null
    {
        $payment_json = json_decode($json);
        if (is_null($payment_json)) {
            return null;
        }
        $key = null;
        if (property_exists($payment_json, "key")) {
            $key = $payment_json->key;
        }
        if (!property_exists($payment_json, "cost")) {
            return null;
        }
        $cost = filter_var($payment_json->cost, FILTER_VALIDATE_FLOAT);
        if ($cost === false) {
            return null;
        }
        if (!property_exists($payment_json, "payment_id") || (!is_string($payment_json->payment_id) && !is_null($payment_json->payment_id))) {
            return null;
        }
        $payment_id = $payment_json->payment_id;
        if (!property_exists($payment_json, "payment_uid") || (!is_string($payment_json->payment_uid) && !is_null($payment_json->payment_uid))) {
            return null;
        }
        $payment_uid = $payment_json->payment_uid;
        if (!property_exists($payment_json, "tokens")) {
            return null;
        }
        if (!property_exists($payment_json->tokens, "tokens") || !is_array($payment_json->tokens->tokens)) {
            return null;
        }
        $credits = 0;
        if ($trusted && property_exists($payment_json, "credits") && is_numeric($payment_json->credits)) {
            $credits = $payment_json->credits;
        }
        $tokens = [];
        foreach ($payment_json->tokens->tokens as $token) {
            $token = self::PARSE_TOKEN($token);
            if (!is_null($token)) {
                $tokens[] = $token;
            }
        }
        if (!property_exists($payment_json->tokens, "decitokens")) {
            return null;
        }
        $decitokens = [];
        foreach ($payment_json->tokens->decitokens as $token) {
            $token = self::PARSE_TOKEN($token);
            if (!is_null($token)) {
                $decitokens[] = $token;
            }
        }
        return new AnonymousTokenPayment($cost, $tokens, $decitokens, $payment_id, $payment_uid, $key, $credits);
    }

    /**
     * Tries to convert a json decoded token object into a Token class 
     * @param object $token
     * @return Token|null
     */
    private static function PARSE_TOKEN(object $token): Token|null
    {
        if (!property_exists($token, "token") || !property_exists($token, "date") || !property_exists($token, "signature")) {
            return null;
        }
        $tokenString = $token->token;
        if (!is_string($tokenString)) {
            return null;
        }
        $tokenSignature = $token->signature;
        if (!is_string($tokenSignature)) {
            return null;
        }
        $tokenDate = $token->date;
        if (!is_string($tokenDate)) {
            return null;
        }
        return new Token($tokenString, $tokenSignature, $tokenDate);
    }

}